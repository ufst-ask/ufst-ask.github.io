[{
	"name": "Disinformation",
	"tags": ["Naming", "_ReffBook", "", "", ""],
	"status": 0,
	"workload": 1,
	"importance": 1,
	"infoBody" : "Avoid disinformation.\ne.g. dont call it claimList if it's not a list but a HashMap.",
	"exampleBad" : "HashMap<Date, Money> claimList = new HashMap<Date, Money>();",
	"exampleGood" : "ArrayList<Claim> claimList = new ArrayList<Claim>();",
	"references" : ["", "",
		"", ""],
	"essentialRule" : "notEssential"
},
	{
		"name": "Pronouncable naming",
		"tags": ["Naming", "_ReffBook", "", "", ""],
		"status": 0,
		"workload": 1,
		"importance": 2,
		"infoBody" : "Use pronounceable names, so you can more easily have a verbal discussion with colleagues about them. Even for those with a strict character limit.",
		"exampleBad" : "DK-HJFFS",
		"exampleGood" : "DK-HJAFS",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Flag arguments, do not use.",
		"tags": ["Functions", "_ReffBook", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 2,
		"infoBody" : "Don't use flag arguments. Meaning don't pass a boolean as an argument into a function. As in, if true do this, if false do that. Then create two functions instead.",
		"exampleBad" : "Claim GetFirstMainOrRelatedClaimInList(Boolean typeIsMainClaim, ClaimList claims) {\nif(typeIsMainClaim) {\n...}\nelse {\n...}\n}",
		"exampleGood" : "Claim GetFirstMainClaimInList(ClaimList claims) {...}\nClaim GetFirstRelatedClaimInList(ClaimList claims) {...}",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Arguments, maximum three",
		"tags": ["Functions", "_Done", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 1,
		"infoBody" : "If you need more than three, consider if some of them could 'be grouped' in an object first.",
		"exampleBad" : "RepossesionCase CreateReposessionCase(Calendar dateRepoStart, String claimId, Money debtAmount, Calendar receiveDate, Money originalDebtAmount) {...}",
		"exampleGood" : "RepossesionCase CreateReposessionCase(Calendar dateRepoStart, Claim claim) {...}",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Arguments, order them as one would expect",
		"tags": ["Functions", "_ReffBook", "", "", ""],
		"status": 0,
		"workload": 1,
		"importance": 1,
		"infoBody" : "_MoreInfoInBook",
		"exampleBad" : "Claim CreateClaim(Money currentAmount, Date receiveDate, Money originalAmount) {...}",
		"exampleGood" : "Claim CreateClaim(Date receiveDate, Money originalAmount, Money currentAmount) {...}",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Variables, declaration placement.",
		"tags": ["Variables", "_ReffBook", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 2,
		"infoBody" : "Declare variables close to their usage. Unless they are used throughout the class, then declare them at the top.",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Keep lines within 120 characters",
		"tags": ["Other", "_Done", "", "", ""],
		"status": 0,
		"workload": 1,
		"importance": 1,
		"infoBody" : "It’s indicated by a vertical grey line in IntelliJ.",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Variables, (almost) never use public",
		"tags": ["Variables", "_ReffBook", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 3,
		"infoBody" : "_MoreInfoInBook",
		"exampleBad" : "public Date claimReceivalDate;",
		"exampleGood" : "private date claimReceivalDate;\npublic Date getClaimReceivalDate() {\nreturn claimReceivalDate;\n}",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Train-wrecks, e.g. 'getSomething().getOtherThing().getGetTheLastThing();'",
		"tags": ["Functions", "_ReffBook", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 1,
		"infoBody" : "Note: Clean Code recommends the opposite of what we do in 'Inddrivelsesprogrammet.'",
		"exampleBad" : "ContextHolder contextHolder = ContextHolder.getContext();\ncontextHolder.flushAllCaches();",
		"exampleGood" : "ContextHolder.getContext().flushAllCaches();",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Outlier cases, create a function",
		"tags": ["Functions", "_ReffBook", "_Example", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 1,
		"infoBody" : "_MoreInfoInBook",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Imports, don't use wildcards",
		"tags": ["Other", "_ReffBook", "", "", ""],
		"status": 0,
		"workload": 1,
		"importance": 1,
		"infoBody" : "Note: Clean Code recommends the opposite of what we do in 'Inddrivelsesprogrammet.' This rule follows our own recommendations.",
		"exampleBad" : "import java.util.*;",
		"exampleGood" : "import java.util.ArrayList;\nimport java.util.List;",
		"references" : ["https://stackoverflow.com/questions/147454/why-is-using-a-wild-card-with-a-java-import-statement-bad", "Stack overflow discussion",
			"https://iciskm.atlassian.net/wiki/spaces/ICINetcompany/pages/36504519/Java+Programming+Guidelines#JavaProgrammingGuidelines-Wildcardimports", "DD160 Programming guidelines"],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Single responsibility, FUNCTION",
		"tags": ["SOLID", "code_review_document", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 3,
		"infoBody" : "Try and describe your function briefly, if you feel the need the to use the word \"and\" it probably does more than one thing and should be split up.\n\nIf you can use IntelliJ extract on it, it probably should be divided into more than one function.\n\nFurther explanation of Single Responsibility Principle: see links below.",
		"exampleBad" : "private void resetRateValueLists() {\n        clearLists();\n        populateRateValueLists();\n    }",
		"exampleGood" : "private void clearLists() {\n        //some functionality here\n    }\n    \nprivate void populateRateValueLists() {\n        //some functionality here\n    }",
		"references" : ["https://stackify.com/solid-design-principles/", "SOLID Design Principles Explained: The Single Responsibility Principle",
			"https://en.wikipedia.org/wiki/Single-responsibility_principle", "Single-responsibility principle"],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Single responsibility, CLASS",
		"tags": ["SOLID", "", "", "", ""],
		"status": 0,
		"workload": 4,
		"importance": 4,
		"infoBody" : "'If we cannot derive a concise name for a class, then it's likely too large. The more ambiguous the class name, the more likely it has too many responsibilities.\"\n§ You should also be able to clearly describe it without using words like \"if\", \"and\", \"or\" or \"but\".\n? The Single Responsibility Principle\n? A class should always only have one reason to change.\n? If the class has few variables which are used repeadetly throughout the class. It's a good indicator that the class is coherent and only has one responsibility'",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["https://stackify.com/solid-design-principles/", "SOLID Design Principles Explained: The Single Responsibility Principle",
			"https://en.wikipedia.org/wiki/Single-responsibility_principle", "Single-responsibility principle"],
		"essentialRule" : "isEssential"
	},
	{
		"name": "Comments should be kept at a minimum, use explanatory code instead.",
		"tags": ["code_review_document", "Other", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 3,
		"infoBody" : "Why: comments are at a greater risk of becoming outdated than actual code. Thus mitigating the risk of misinformation.",
		"exampleBad" : "Date date = new Date(2019, 6, 30); //Creating the last date in June 2019",
		"exampleGood" : "Date lastDayInJune2019 = new Date(2019, 6, 30);",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Catch block, don’t use your own with jUnit",
		"tags": ["Tests", "", "", "", ""],
		"status": 0,
		"workload": 3,
		"importance": 2,
		"infoBody" : "'Do not write your own catch block. Method of jUnit are able to catch them. If you use your own catch block you are doing redundant code.'",
		"exampleBad" : "@Test\npublic void testMethod() {\n    try {\n        //SomeCode\n    } catch (Exception e) {\n        // catch code\n    }\n}",
		"exampleGood" : "@Test\npublic void testMethod() throws Exception {\n  //Some code that can throw any exception.\n}",
		"references" : ["https://iciskm.atlassian.net/wiki/spaces/ICINetcompany/pages/36504519/Java+Programming+Guidelines#JavaProgrammingGuidelines-Besttestpractices", "DD160 Programming guidelines",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Namelengths, should correspond to scope",
		"tags": ["Naming", "", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 1,
		"infoBody" : "The length of a name should correspond to the size of its scope\nSingle letter variables only allowed inside very small methods. E.g. i within a loop",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "prefix, use it in variable names when context isn’t obvious",
		"tags": ["Naming", "Variables", "", "", ""],
		"status": 0,
		"workload": 1,
		"importance": 2,
		"infoBody" : "Ideally context is obvious from the variables being grouped in small single purpose classes.\n\nAlternatively, use a prefix to state the context.",
		"exampleBad" : "",
		"exampleGood" : "string employeeId, employeeAddress, employeeName;\nstring roomId, roomAddress, roomSize;",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Indents, use max two per function",
		"tags": ["Functions", "", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 2,
		"infoBody" : "You should never need to indent more than twice within a function.\nIf you feel the need, you probably should make a call to a separate function instead.\nWithin any if, else or while statement you should only need one line. Which usually would be a function call.\n\nThis also provides an opportunity to make the code more self-explanatory with a meaningful function name, rather than code with comments.",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Switch statements, should be avoided",
		"tags": ["Other", "", "", "", ""],
		"status": 0,
		"workload": 1,
		"importance": 1,
		"infoBody" : "They risk growing as new cases become needed. I.e. it may become too big and change too much from when you first wrote it.",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Function arguments, use max 3",
		"tags": ["Functions", "", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 2,
		"infoBody" : "Never use more than three function arguments, preferably 0 or 1.",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Error handling, separate it into it's own class",
		"tags": ["Tests", "", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 2,
		"infoBody" : "Separate error-handling from the code. Have that in a class by itself. Usually \"just\" one class per area of code.",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "null, use exceptions instead of returning or passing null",
		"tags": ["code_review_document", "Functions", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 2,
		"infoBody" : "Don't ever return null. And never, ever pass null\n\"If you are tempted to return null from a method, consider throwing an exception or returning a SPECIAL CASE object instead. If you are calling a null-returning method from a third-party API, consider wrapping that method with a method that either throws an exception or returns a special case object.\"",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "ATEST structure: build ? operate ? check",
		"tags": ["Tests", "", "", "", ""],
		"status": 0,
		"workload": 1,
		"importance": 1,
		"infoBody" : "\"The BUILD-OPERATE-CHECK pattern. Tests should be clearly split into three parts. The first part builds up the test data, the second part operates on that test data, and the third part checks that the operation yielded the expected results.\" (Modified quote from book)",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Functions used in more than one test, place them in utility classes",
		"tags": ["Functions", "", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 3,
		"infoBody" : "Use utility classes for when writing tests. It's also normal and good practicate to let those evolve over time.",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Assertions, keep them to a minimum",
		"tags": ["Tests", "", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 2,
		"infoBody" : "Keep the amount of asserts in a test to a minimum. If you have many, consider splitting up the test into more tests.\n\nAnd test only one \"concept\" per test.",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Proper naming of variables, functions and classes",
		"tags": ["code_review_document", "Naming", "", "", ""],
		"status": 0,
		"workload": 2,
		"importance": 3,
		"infoBody" : "The name should answer:\n- Why it exists\n- What it does\n- How it is used",
		"exampleBad" : "int days;",
		"exampleGood" : "int elapsedTimeInDays;",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Functions, structure them properly",
		"tags": ["Functions", "", "", "", ""],
		"status": 0,
		"workload": 3,
		"importance": 2,
		"infoBody" : "(More info to come)",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Open-closed. Follow open-closed principle",
		"tags": ["SOLID", "", "", "", ""],
		"status": 0,
		"workload": 5,
		"importance": 4,
		"infoBody" : "Since we use Clean Code, we should use Polymorphic version.\nMeaning: \"Interface specifications can be reused through inheritance but implementation need not be. The existing interface is closed to modifications and new implementations must, at a minimum, implement that interface.\"",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle", "Wiki, Open–closed principle",
			"https://stackify.com/solid-design-open-closed-principle/", "The Open/Closed Principle with Code Examples"],
		"essentialRule" : "isEssential"
	},
	{
		"name": "Liskov substitution principle",
		"tags": ["SOLID", "", "", "", ""],
		"status": 0,
		"workload": 5,
		"importance": 4,
		"infoBody" : "\"S is a subtype of T, then objects of type T may be replaced with objects of type S\"",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["https://en.wikipedia.org/wiki/Liskov_substitution_principle", "Wiki",
			"https://stackify.com/solid-design-liskov-substitution-principle/", "The Liskov Substitution Principle with Code Examples"],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Interface segregation principle",
		"tags": ["SOLID", "", "", "", ""],
		"status": 0,
		"workload": 5,
		"importance": 4,
		"infoBody" : "",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["https://en.wikipedia.org/wiki/Interface_segregation_principle", "Wiki, Interface segregation principle",
			"https://stackify.com/interface-segregation-principle/", "Interface Segregation with Code Examples"],
		"essentialRule" : "isEssential"
	},
	{
		"name": "Dependency inversion principle",
		"tags": ["SOLID", "", "", "", ""],
		"status": 0,
		"workload": 5,
		"importance": 4,
		"infoBody" : "",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["https://en.wikipedia.org/wiki/Dependency_inversion_principle", "Wiki, Dependency inversion principle",
			"https://stackify.com/dependency-inversion-principle/", "Dependency Inversion Principle with Code Examples"],
		"essentialRule" : "isEssential"
	},
	{
		"name": "Test locally before code review.",
		"tags": ["code_review_document", "Precondition", "", "", ""],
		"status": 0,
		"workload": 0,
		"importance": 0,
		"infoBody" : "Developers should have built and tested the code locally before handing it over to a reviewer",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Commit size, should be possible to review in less than 2 hours.",
		"tags": ["code_review_document", "Precondition", "", "", ""],
		"status": 0,
		"workload": 0,
		"importance": 0,
		"infoBody" : "Tasks shall never be too big for the review to be able to be done in less than two hours. If a developer gets a task that by mistake is too big, then divide it into smaller cohesive tasks.\nA commit should not be more than 400 lines of code.",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "PSRM scripts, use java instead when possible",
		"tags": ["code_review_document", "Precondition", "", "", ""],
		"status": 0,
		"workload": 0,
		"importance": 0,
		"infoBody" : "Kunne nogle af PSRM scriptsne flyttes over i Java?",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "SQL, use java instead when possible",
		"tags": ["", "", "", "", ""],
		"status": 0,
		"workload": 0,
		"importance": 0,
		"infoBody" : "Kunne noget af den logik der ligger på databasen flyttes over i Java?",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Requirements, are they followed? ",
		"tags": ["code_review_document", "", "", "", ""],
		"status": 0,
		"workload": 0,
		"importance": 0,
		"infoBody" : "Does it work, that is not only work but work as the requirements instruct. Make sure data is both received and passed on correctly the handshake is the key.",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Check for errors, vulnerabilities, inconsistency and redundant code.",
		"tags": ["code_review_document", "", "", "", ""],
		"status": 0,
		"workload": 0,
		"importance": 0,
		"infoBody" : "",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Warnings, there should be 0 project warnings.",
		"tags": ["code_review_document", "", "", "", ""],
		"status": 0,
		"workload": 0,
		"importance": 0,
		"infoBody" : "There should be 0 project warnings in IntelliJ and SonarQube (SonarLint if you don’t have full)",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Logging of business decisions ",
		"tags": ["code_review_document", "", "", "", ""],
		"status": 0,
		"workload": 0,
		"importance": 0,
		"infoBody" : "Check for proper logging of ALL business decisions. And their foundation.",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "SQL, optimize the queries",
		"tags": ["code_review_document", "", "", "", ""],
		"status": 0,
		"workload": 0,
		"importance": 0,
		"infoBody" : "Check database queries if they are optimized. Or if using hibernate query language check that the code result in optimized SQL arriving on the database.",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "API request / service calls",
		"tags": ["code_review_document", "", "", "", ""],
		"status": 0,
		"workload": 0,
		"importance": 0,
		"infoBody" : "Are there multiple API requests/Service calls, could they be optimized are they to wide?",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Load / get data that is redundant",
		"tags": ["code_review_document", "", "", "", ""],
		"status": 0,
		"workload": 0,
		"importance": 0,
		"infoBody" : "Does it load/get data for things that are not used?",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Caching to improve performance",
		"tags": ["code_review_document", "", "", "", ""],
		"status": 0,
		"workload": 0,
		"importance": 0,
		"infoBody" : "",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	},
	{
		"name": "Security, send/receive only the absolutely needed information, for security.",
		"tags": ["code_review_document", "", "", "", ""],
		"status": 0,
		"workload": 0,
		"importance": 0,
		"infoBody" : "",
		"exampleBad" : "",
		"exampleGood" : "",
		"references" : ["", "",
			"", ""],
		"essentialRule" : "notEssential"
	}
]